# 性能相关

## 早期架构
1. 主要矛盾是CURD频繁出错，SQL调试困难，所以需要一些ORM
2. 使用自己擅长的
3. 统一技术栈
4. 浅浅封装一层  
```java
String get(String key) {
	return jedis.get(key);
}
```
方便后期拓展

## 容量设计
需要预估的指标，具体需要根据系统判断：

1. 数据量
2. 并发量，吞吐量
3. 带宽
4. cpu/mem/disk

### 评估步骤
1. 总访问量，一般由业务估计

2. 评估平均吞吐量QPS

3. 评估峰值吞吐量QPS  
  绘制业务图，通过看平均值与峰值比例

4. 评估单机极限QPS  
  可根据一些常识，压测评估

5. 根据线上冗余度做决策

    单机一般不会跑慢，打8折，然后通过峰值处以八折单机QPS，得到线上冗余度（应该部署的机器数）

## 系统拆分

all in one 的劣势：单机资源成为瓶颈

### 多机架构，伪分布式：三大分离

将能够分离的资源，从单一资源中分离出来，解决单机资源瓶颈，提高系统性能

ps：此时

1. db：读写分离，提高读写性能，但会带来主从延迟
2. 前后分离：动静分离
3. 前后台分离：系统拆分成前后台系统

### 业务垂直拆分

三大分离并不能解决一个系统挂了，不影响其他系统的问题（耦合），这时候就需要业务垂直拆分了。

按照业务线垂直拆分，可分为：

1. 业务垂直拆分：拆分业务线
2. 代码垂直拆分：拆分项目
3. 数据库垂直拆分：降低数据量，不同应用使用不同数据库，降低主从延迟
4. 研发团队垂直拆分

# 接入层

## 反向代理

伪集群并不是高可用的，通过反向代理，可以建立真正的集群，实现高可用

### 方式

1. 软件：nginx/apache
2. 操作系统：LVS
3. 硬件：F5

### 带来新的问题

1. 负载均衡方式
    1. 随机
    2. 轮询
    3. 静态权重轮询：静态设置机器权重
    4. 动态权重轮询：实际处理能力决定机器权重
    5. 一致性哈希：session一致性等问题
        1. 四层转发：传输层，通过ip+端口
        2. 七层转发：http协议，通过userId等字段
2. 反向代理服务器高可用
    1. 集群，同虚拟ip（VIP），主备+keepalive的方式，但会导致资源利用率降低
    2. vip：虚拟ip，基于VRRP协议，实现路由器高可用，即防止IP单节点崩溃，具体是通过ip上层的链路层的多播实现
    3. nginx集群负载均衡
        1. 单域名轮询多ip，故障切负会慢
        2. 使用F5等硬件做域名解析转发

### DNS轮询

DNS-Server可以配置一个域名对应多个IP，早期没有nginx等反向代理技术时，就是这样做集群方案的

### 缺点

1. 不能感知服务IP是否挂了，没办法切到正常结点，仍然不是高可用的，部分流量受影响
2. 暴露太多外网ip
3. dns新增结点需要扩散全网，具有延迟

### 加入反向代理后

1. 延迟更高，因为多了一层
2. 解决了上述，部分高可用、外网ip太多、新增结点延迟的问题

### 高可用高性能的nginx集群架构

nginx的吞吐量大概为1秒1W访问量，当超过这个量级该如何设计，反向代理层的高性能

1. 多层反向代理

     通过LVS或者F5做nginx的上一层代理，此时nginx不需要做VIP，但系统更复杂，且LVS和F5也会有上限

2. DNS轮询 + 反向代理高可用

    1. DNS轮询

        使反向代理可以水平扩展，通过加机器就能增加系统吞吐量，解决性能拓展问题

        ps：此处可做多层反向代理，也可以直接使用nginx

    2. 反向代理高可用

        但需要对DNS映射的每个反向代理结点做keepalive+VIP的主备，解决高可用问题

## session一致性

1. 客户端存储

    1. 占用外网带宽
    2. 容易泄密，篡改
    3. 但可以减少服务器压力

2. 反向代理hash一致性

    session信息存在应用服务器内存，高可用导致需要用户代理到同一服务器

    1. 四层：ip哈希一致
    2. 七层：sessionId等应用层字段
    3. 优点：容易实现，修改nginx配置即可，不需要改动应用服务
    4. 缺点：部分用户需要重新登陆
        1. 水平拓展导致重新hash
        2. 结点重启，丢失部分用户信息
    5. 选择：建议使用四层转发，nginx是反向代理服务器，让反向代理做转发应该做的事情（处理IP）

3. 后端存储session信息

    1. db
    2. redis
    3. 缺点：
        1. 多了一次网络IO，原先是存在应用服务器内存
        2. 应用代码管理session
    4. 优点：
        1. 不会重新登陆
        2. 数据量大时，数据库水平切分即可

## CDN加速

### 就近访问

不同地区客户端返回不同机房，流程为

1. 解析域名，通过智能DNS返回客户端就近机房
2. 访问就近机房

### cdn架构

1. 源
2. 镜像：缓存
3. 智能DNS

### 镜像和源数据一致性问题解决方案

1. 缓存淘汰：源更新的时候，过期镜像，使得源依赖于镜像，存在耦合
2. 缓存过期：用户体验不好
3. 版本号：对于经常升级的静态资源，可加上版本号

### 资源更新

1. 源推送，依然存在耦合
2. 镜像主动拉取源

## TCP负载均衡

tcp不同于http的负载均衡时，tcp是长连接，需要保证每次传输落在同一台服务器上

### 客户端负载均衡

内置tcp集群

1. 内置域名，每次建立连接访问dns

    缺点是每次都需要访问多一次dns，且可能被dns劫持

2. 内置ip，ip直通车

    更新困难

### 服务端负载均衡

1. 新增一台web-server，客户端每次建立tcp连接时，先http访问web-server获取一个静态ip

    web-server无法感知tcp-client的存活状态，没办法保证高可用

2. tcp-client定时上报web-server

    反向依赖耦合，tcp-client作为业务服务，依赖web-server这种业务无关的应用

3. web-server主动拉取tcp-client状态

服务端做，可实施过载保护

## 动静分离

### 动态页面

1. 分层架构
2. 服务化架构
3. 数据库，缓存架构

### 动静分离

### 页面静态化

将需要动态访问后端的页面，提前生成好html文件，使用静态资源优化的手段

适用的场景：结果集有限，如城市页

不适合的场景：结果集数量大，如帖子、搜索，并且变化频率高

## 读写分离，前后台分离

### 主从分离

主从同步，读从库，提升读性能瓶颈

### 水平分离

水平分表分库，提高写性能

### 前后台分离

前台数据结构化，改动较小；后台数据容易变化，升级多；

前后台DB分离，后台DB通过增加转换任务，同步至前台DB，前后台解耦；



# 服务化

## 什么时候需要服务化

1. 代码到处拷贝
2. 底层复杂性扩展：如水平分表、做缓存，每个应用都需要升级，提高专注性
3. 公共库耦合：维护多个版本，如果不向上兼容，一条业务线升级需要其他所有业务线升级
4. 数据库耦合：如果各个业务线有依赖用户表的个性表时，使用join语句会导致所有业务线的个性表都得和用户表在同一个数据库
5. 代码质量：代码质量有保障，尤其是sql，避免一个业务低级开发低级sql，给整个数据库带来压力

最大的好处：简化调用方，使调用方更专注自身业务

带来的问题：

1. 系统复杂性上升
2. 层次间依赖关系变得复杂，可能变成网状结构
3. 运维、部署困难
4. 监控、定位问题困难

## 服务粒度

1. 一个子业务一个服务

    互联网最常用！！！

2. 一个数据库一个服务

3. 一个接口一个服务

    多个接口分成不同服务，访问同一数据库，一般轻量级语言才可以这么做，比如GO

### 细的优点

1. 耦合性低
2. 可拓展高

### 细的缺点

1. 开发难以维护
2. 应用过多
3. 运维手段瓶颈

## 微服务的高可用

### 手段

1. 集群化（冗余）
2. 故障自动转移

### rpc高可用

rpc-client中的连接池，服务提供者挂了，可以通知到客户端连接池

### 缓存不雪崩（高可用）

数据分片，通过key水平切分至不同分片，缓存挂了只影响部分数据，需要加上一层缓存代理（one cache）

### 数据库高可用

读写分离，一主多从

写库高可用：keepalived + vid，并且设置相互同步（阿里云高可用主库rds的方案）

# 数据库

## 读性能提升

### 1、建立索引

#### 问题

1. 写性能降低

    索引越多，B+树自旋越多

2. 占用大量内存，占用buffer较多，buffer命中率降低，可能影响读性能

#### 拓展

可对不同从库区分使用场景，建立不同的索引，但会带来运维复杂度；主库不设置索引，增加写性能

### 2、增加从库

主从同步，分组结构：

解决问题：

1. 读高可用
2. 读性能线性拓展

未解决：

1. 写高可用
2. 数据量拓展

带来问题：

1. 主从同步不一致

### 缓存

先读缓存，否则读库并缓存

带来问题：防止雪崩！！

1. 缓存雪崩
    1. 缓存高可用
    2. 水平切分缓存：分片后，某个分片挂掉，该分片所有流量打到数据库，但此时数据库也应该能承受住（所以必须根据数据库性能去预测计算缓存分片数量）
2. 读写流程更复杂
    1. 写：先淘汰缓存
    2. 读：数据库、缓存不一致