# 时间复杂度

## 大O表示法

T(n) = O(n)；

1. 只需要记录最大量级
2. 常量可以无视

### 时间复杂度分析

1. 循环次数最多的代码

2. 加法法则

    多段代码：总复杂度等于量级最大的复杂度

3. 乘法法则

    嵌套代码：复杂度等于嵌套内外代码复杂度乘积

### 常见复杂度

1. 常量阶 O(1)

2. 对数阶 O(log n)

    由于底数可以互相转换，所以忽略底，如：log3 n * log2 3 = log2 n，log2 3是个常量

3. 线性阶 O(n)

4. 线性对数阶 O(n * log n)

5. 平方阶、立方阶、x次方阶  O(n^x)

6. 指数阶  O(2^n)

7. 阶乘阶 O(n!)

## 最好、最坏、平均、均摊时间复杂度

示例代码：

```java
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
	int i = 0;
	int pos = -1;
	for (; i < n; ++i) {
		if (array[i] == x) {
			pos = i;
			break;
		}
	}
	return pos;
}
```



### 最好时间复杂度

最理想的情况，如例子，第一个就是所查找的元素，则是O(1)

### 最差时间复杂度

最糟糕的情况，如例子，数组中没有该元素，需要遍历整个数组，则为O(n)

### 平均复杂度

通过每种情况的概率*对应复杂度，求和得出的复杂度（加权平均值)，即为平均复杂度

例子中，首先是出现和不出现在数组里，概率分别为1/2，再对应出现在数组里的所有，算出来为 (3n+1)/4，用大O表示法仍为O(n)

### 均摊时间复杂度

针对一些有规律的场景，如数组插入平时是O(1)，在容量满之后会有一次触发扩容，此时需要挪动数组，是O(n)，但是这都是有规律的，可以不需要用概率论算出加权平均值，而直接分摊到前面n次操作即可，即仍然是O(1)。该结果与概率论算出的一致。