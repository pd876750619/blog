## 配置

### 连接池

#### hikari

##### 使用了数据库端已经超时的连接，验证失败，导致超时

报错如下：

```java
2020-07-14 11:58:38.036  WARN 251412 --- [nio-8085-exec-5] c.z.h.p.PoolBase                         : HikariPool-1 - Failed to validate connection 
com.mysql.cj.jdbc.ConnectionImpl@795d15b3 (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.
org.springframework.transaction.CannotCreateTransactionException: Could not open JDBC Connection for transaction; nested exception is java.sql.SQLTransientConnectionException: HikariPool-1 - Connection is not available, request timed out after 10013ms.
	at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:308) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.startTransaction(AbstractPlatformTransactionManager.java:400) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:572) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:360) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) ~[spring-tx-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
```

原因是连接池配置的问题，一般情况下会根据数据库的配置去做连接池的配置，具体的配置项为

1. idle-timeout：一个连接idle状态的最大时长（毫秒），超时则被释放（retired），缺省:10分钟
2. maxLifetime：一个连接的生命时长（毫秒），超时而且没被使用则被释放（retired），缺省:30分钟，建议设置比数据库超时时长少30秒，参考MySQL wait_timeout参数

但是此处hikari有个校验条件：idleTimeout+1秒 > maxLifetime 且 maxLifetime > 0，idle-timeout则会被重置为0（代表永远不会退出）；

此处我踩得坑为未设置maxLifetime，却设置了idle-timeout为30S，此时maxLifetime使用默认值30S，则会触发校验，使idle-timeout则会被重置为0

```yaml
hikari:
  auto-commit: true
  allow-pool-suspension: true
  data-source-properties:
    cachePrepStmts: true
    prepStmtCacheSize: 250
    prepStmtCacheSqlLimit: 2048
    useServerPrepStmts: true
  connection-timeout: 10000
  maximum-pool-size: 100
  minimum-idle: 5
  idle-timeout: 30000
  max-lifetime: 50000
```